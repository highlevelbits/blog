---
title: "A whole new world"
kind: article
created_at: 2008-01-16 21:31:00
author: hardy
tags: java
---
  <p>I was just reading the latest &#39;<a href="http://www.javaspecialists.eu/archive/Issue155.html" id="kfs6" title="The Java Specialists' Newsletter">The Java Specialists&#39; Newsletter</a>&#39; - I am not sure if I have mentioned this newsletter and the name of <a href="http://www.javaspecialists.eu/index.jsp" id="brxi" title="Dr. Heinz M. Kabutz">Dr. Heinz M. Kabutz</a> on this blog before - when I realized how interesting and potentially far reaching implications the usage of Strings can have. I consider myself to be a competent Java developer and I know that if I want to concatenate Strings I should use a StringBuilder or StringBuffer. However, I did not know that I should not synchronize on a String. I probably would not have done it anyway, since some long time ago I&#39;ve learned to synchronize on an Object instance, but I did not know why I should do it this way. I also did not know what exactly String.intern()is good for. I have seen it many times browsing the Java Docs, but never really took the time to understand it.<br /><br />Anyways, reading the newsletter I got intrigued and started to surf the net for more information and soon realized how far reaching the simple usage of a String can become and that String manipulation could be the cause of performance problems. This blog entry I found especially interesting - <a href="http://thought-bytes.blogspot.com/2007/03/java-string-performance.html" id="ckjq" title="Java String performance">Java String performance</a>. However, I don&#39;t think you should refactor all your String usage now. I am a firm believer in profiling before improving, but it is still interesting to keep certain facts about such a simple thing as String usage stored away in some dark corner of your brain.<br /><br />This little excursion into the world of Strings also reminded me of an article I read a while ago (unfortunately I just cannot dig it up again - maybe someone else can help?). In essence the article tried to answer the question whether all the layers of abstraction we have within the IT world really make it easier, quicker and safer to implement applications. Somehow it does, however each single abstraction is build by humans, meaning it is as prone to error and bugs than the very application you try to write using these abstractions. If you are sitting somewhere at the top of this pile of abstractions and a lower level abstraction fails how possible is it that you are able to understand and fix the problem? Will it not become harder and harder to control all these layers and abstractions. Taking the example of a String - who out there can still explain to me all the layers involved manipulating this string. Starting with the JVM, over to the OS and IO operations all the ways down to CPU registers.</p><div class="old-comments"><h2>Old comments</h2><div class="one-old-comment"><span class="comment-date">2008-01-20</span><span class="commenter-name">Fredrik Rubensson</span><div class="comment-body">Sure are lots to think about when it comes to performance. I occasionally read parts of <A HREF="http://java.sun.com/docs/books/effective/" REL="nofollow">Effective Java</A> by Joshua Bloch - a book that describes many of the inner workings of Java. It's a bit old (2001) - it would be nice with a new one including features of Java 5. And there probably are changes to the implementation in many of the areas covered by the book. <BR/><BR/>I am not sure about the layer thing. I would argue that stable layers is a good thing because the abstraction level can be higher when there are a stable foundation that hides all the boring details. Unstable layers though..... Thinking about a certain OS for example that messes up the life of software developers most of the time. But no one questions the usefulness of a compiler or a relational database. It is important to hook in at the right level. If your application needs details then maybe it should be written at a lower level of abstraction. (Or if it needs to be really fast or safe.)</div></div></div>