<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://www.highlevelbits.com/</id>
  <title>atom feed</title>
  <updated>2013-04-22T22:00:00Z</updated>
  <link rel="alternate" href="http://www.highlevelbits.com/"/>
  <link rel="self" href="http://www.highlevelbits.com/atom.xml"/>
  <author>
    <name>Fredrik &amp; Hardy</name>
    <uri>http://www.highlevelbits.com</uri>
  </author>
  <entry>
    <id>tag:www.highlevelbits.com,2013-04-23:/2013/04/tdding_prime_detection.html</id>
    <title type="html">detecting prime numbers with Test Driven Development</title>
    <published>2013-04-22T22:00:00Z</published>
    <updated>2013-04-22T22:00:00Z</updated>
    <link rel="alternate" href="http://www.highlevelbits.com/2013/04/tdding_prime_detection.html"/>
    <content type="html">&lt;p&gt;This tuesday I held a half day workshop on Test Driven Development for a group of developers
at Smart Bears Stockholm office. I prepared by writing a
&lt;a href="/2013/04/what_is_tdd.html"&gt;generic post about TDD&lt;/a&gt; explaining the main principles. During the
session we used prime number detection as an example kata. This is a very simple problem and
as such useful to show how to do proper TDD. On the other hand there isn’t much of real world
problems in there. We started with the tiniest test:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Test
public void oneIsPrime(){
    assertTrue("1 should be a prime", Prime.isPrime(1));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and implemented this with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Prime {
  public static boolean isPrime(int number){
    return true;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This piece of code is the best thing that fulfills our test so there is no need to get into the
refactor phase at this stage. The language is called Java if you don’t recognize it.&lt;/p&gt;

&lt;p&gt;The next test takes the first non prime number and test it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Test
public void fourIsNotPrime(){
    assertFalse("4 should not be a prime", Prime.isPrime(4));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;implemented with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static boolean isPrime(int number){
    if( number == 4 ) return false;
    return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now this can be refactored:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static boolean isPrime(int number){
    return number != 4;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the refactoring doesn’t add functionality - it just makes the code easier to read. Add another
non-prime:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Test
public void nineIsNotPrime() {
    assertNotPrime(9);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and helper methods to make the test code a little bit easier to read:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void assertNotPrime(int number){
    String message = "" + number + " should not be a prime";
    assertFalse(message, Prime.isPrime(number));
}

public void assertPrime(int number){
    String message = "" + number + " should be a prime";
    assertTrue(message, Prime.isPrime(number));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Actually in the workshop we didn’t break out the asserts into methods but went straight for the
next test code refactoring. The code under test is still naive:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static boolean isPrime(int number){
    if( number == 4 || number == 9 ) return false;
    return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we felt the need to introduce an easier way to test many combinations at once. This is a bit awkward in
Java and come much more natural in a dynamic language. We used the junit runner Parameterized to be able to
have one test for each prime we’d like to test while reusing as much of the test code as possible. Here is the
implementation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package prime;

import java.util.*;

import org.junit.*;
import org.junit.runner.*;
import org.junit.runners.*;
import org.junit.runners.Parameterized.*;

import static org.junit.Assert.*;

@RunWith(Parameterized.class)
public class TestPrime {
    private int number;
    private boolean isPrime;

    public TestPrime(int number, boolean isPrime){
        this.number = number;
        this.isPrime = isPrime;
    }

    @Parameters
    public static Collection&amp;lt;Object[]&amp;gt; bunchOfPrimes(){
        return Arrays.asList(new Object[][]{
            {1, true},
            {2, true},
            {3, true},
            {4, false},
            {7, true},
            {9, false},
            {10, false},
            {13, true},
            {15, false}
        });
    }

    @Test
    public void isPrime(){
        if(this.isPrime){
            assertPrime(this.number);
        } else {
            assertNotPrime(this.number);
        }
    }

    public void assertPrime(int number){
        String message = "" + number + " should be a prime";
        assertTrue(message, Prime.isPrime(number));
    }

    public void assertNotPrime(int number){
        String message = "" + number + " should not be a prime";
        assertFalse(message, Prime.isPrime(number));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the code that I prepared before the session. When we programmed it in the session we ended up with
using &lt;code&gt;assertEquals&lt;/code&gt; instead of having the helper methods and I think that was a nicer approach.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Parameterized&lt;/code&gt; requires a method that returns test data. It should have the awkward return type
&lt;code&gt;Collection&amp;lt;Object[]&amp;gt;&lt;/code&gt; - that is a collection of object arrays. Each member of the array should have
data so that the test class constructor can be called. In our case there is a number - the prime candidate -
and a boolean indicating if it is expected to be a prime or not. The runner creates one instance per
data point and runs all Test methods on that one. In our case there is only the &lt;code&gt;isPrime&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;Now all there is left is to implement the real stuff:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static boolean isPrime(int number){
  for(int i = 2; i &amp;lt; number; i++) {
    if(number % i == 0) {
      return false;
    }
  }
  return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and a somewhat refactored solution:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static boolean isPrime(int number){
  for(int i = 2; i &amp;lt;= sqrt(number); i++) {
    int remainder = number % i;
    if(remainder == 0) {
      return false;
    }
  }
  return true;
}

private static double sqrt(int number){
  return Math.sqrt(number);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This was a fun but naive exercise. You can follow this code step-by-step in
&lt;a href="https://github.com/froderik/javaprime"&gt;this github repo&lt;/a&gt;.
There are commits and tags for each step in the TDD cycle. There is also a slightly more advanced example
with prime factorizations.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <id>tag:www.highlevelbits.com,2013-04-14:/2013/04/what_is_tdd.html</id>
    <title type="html">what is tdd?</title>
    <published>2013-04-14T12:12:12Z</published>
    <updated>2013-04-14T12:12:12Z</updated>
    <link rel="alternate" href="http://www.highlevelbits.com/2013/04/what_is_tdd.html"/>
    <content type="html">&lt;p&gt;I am doing a bit of coaching on Test Driven Development (TDD) this month and had to start
think about the topic a bit and thus this post. I have been doing TDD since the ages of
eXtreme Programming in the late 90’s. It now is so natural to me so I never feel done
without having proper code coverage. Yet at times there are circumstances where I decide
not to do it and that has almost always to do with large code bases without existing test
infrastructure. The cost to get started can be so high sometimes. This piece will include
a definition of TDD and a collection of things to keep in mind when practicing it. In a
future post I will step you through a code example using the technique.&lt;/p&gt;

&lt;p&gt;Many may think of TDD as something related to testing and quality - boooooring stuff. In
fact it turns out that it is truly a software development method. When applied consistently
it helps with many of the typical problems software projects encounter. I will end this post
with discussing the benefits of TDD.&lt;/p&gt;

&lt;p&gt;The classic way to describe TDD is with the red-green-refactor mantra and I think it is
really good to have this &lt;em&gt;easy to understand&lt;/em&gt; description of the concept. Red -
write at test that fails, green - unfail the test, refactor - adapt the resulting code
with its surroundings. Lets examine these parts one by one.&lt;/p&gt;

&lt;h3 id="red"&gt;Red&lt;/h3&gt;

&lt;p&gt;In the red phase - &lt;strong&gt;write a test&lt;/strong&gt; that fails. This is the specification of what you are about
to do next. It defines the scope of the task. You may want to understand it as your &lt;em&gt;definition
of done&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;This test should test only one thing in order to keep changes small. If the test is small - it is
likely that the code fulfilling the test also will be small and you’ll end up with a nice change
set to put in your repository.&lt;/p&gt;

&lt;p&gt;It may help thinking about specifications rather than tests. What you really do when writing
the test upfront is designing the interface of the unit under test. It is the first usage of
the upcoming code and as such is a great way to understand what is really needed from the code.&lt;/p&gt;

&lt;p&gt;&lt;a href="http://www.flickr.com/photos/martinlabar/159577406"&gt;&lt;img style="float:right" src="http://farm1.staticflickr.com/64/159577406_f681497ca1.jpg" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id="green"&gt;Green&lt;/h3&gt;

&lt;p&gt;In the green phase - &lt;strong&gt;unfail the test&lt;/strong&gt; - write the code that makes the test pass. May it be with
shortcuts, magic numbers and whatnots. It should make the test pass - nothing more, nothing less.
Most of the thinking has already been done in the red phase so this may turn out to be rather easy.
Actually - if it turns out to be hard it may well be that the test written is a bit too large.&lt;/p&gt;

&lt;h3 id="refactor"&gt;Refactor&lt;/h3&gt;

&lt;p&gt;In the refactor phase - &lt;strong&gt;rewrite the code&lt;/strong&gt; written in the green phase. I like to think of this
as adapting the new code into the surrounding code base. Another way to put it is: remove duplication.
The most important thing to keep in mind during this phase is to NOT ADD ANY FUNCTIONALITY. The code
should behave exactly the same but now be written in a way that is readable and maintainable. How exactly
this is may differ between languages, organisations and teams. To make sure that the code really conforms
to the standards set you could choose between &lt;em&gt;pair programming&lt;/em&gt; and &lt;em&gt;code review&lt;/em&gt;. It may also be
helpful to have som static code analyzers in place to detect common mistakes.&lt;/p&gt;

&lt;h3 id="understand"&gt;Understand&lt;/h3&gt;

&lt;p&gt;When thinking about processes and methods I sometimes fall back to this kentbeckism:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Listening, Testing, Coding, Refactoring.
That’s all there is to software.
Anyone who tells you different is selling something.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As you can see red-green-refactor maps nicely to testing-coding-refactoring and then we have the added
&lt;em&gt;listening&lt;/em&gt;. What this means - of course - is to make sure that you build the right stuff. You have
to listen to the user of the system, you have to listen to (understand) the domain you work in. Only
then can you make sure that the spec you will be writing in the red phase is the right spec. If the
spec is not what is needed the whole cycle will be waste.&lt;/p&gt;

&lt;p&gt;With that said the basics has been covered. Lets take a look at some issues and possibilities.&lt;/p&gt;

&lt;h3 id="coding-guidelines"&gt;Coding guidelines?&lt;/h3&gt;

&lt;p&gt;Way back I often regarded test code as something that could be treated without care - a possibility to
do some cowboy hacking. This is a dangerous stand. Nowadays I think that the test code may be the most
important code to keep in shape. If well written it will serve as documentation for the system. In any
living system it is also the place where any new developer starts off when making changes. It should
be easy to add and alter tests. Generally it is wise to have the same coding guidelines for test code
as for the system as a whole. The only thing that may differ is the degree of DRY (don’t repeat yourself).
Readable test code may sometime benefit from duplication. Setup code that calls generic methods makes
the test hard to follow - better to hardwire setup data that is relevant for the test and hide any setup
that is just boiler plate. Readability is more important than DRY-ness when it comes to test code.&lt;/p&gt;

&lt;h3 id="test-to-code-mapping"&gt;Test to code mapping&lt;/h3&gt;

&lt;p&gt;A common practice is to have one test class per class and often you also see one test method per method.
This may or may not be a good idea. The class-to-class mapping is good most of the time since it is
really easy to find relevant tests. If test files are growing out of control it is probably an indication
that the unit under test is in need of refactoring. The same goes for methods. A test method should test
one thing and if the method under test can be tested with only one test method this is good. But in many
cases this makes for bad test design so it really depends. Which leads us to….&lt;/p&gt;

&lt;h3 id="test-design"&gt;Test design&lt;/h3&gt;

&lt;p&gt;While a good design may emerge from TDD it may be easy to forget the design of the test code itself.
The common principles of designing software should be applied equally to this code but with readability
as the most important aspect.&lt;/p&gt;

&lt;h3 id="coverage"&gt;Coverage&lt;/h3&gt;

&lt;p&gt;Ideally - every code line is covered when running all tests. This is almost never the case. Some languages
makes it hard to get full coverage (think about javas checked exceptions that never occur). Legacy code
bases may have areas where intermingling dependencies makes it impossible to add any unit tests at all.
Black box acceptance like tests are likely the best approach to these cases. That said, it is never a bad
thing to strive for 100% code coverage. One way to make this possible is to stay small. If a method under
test does one thing it may be tested with one scenario but if it does several different things the number of
needed scenarios will multiply and increase the test code size exponentially.&lt;/p&gt;

&lt;p&gt;&lt;a href="http://www.flickr.com/photos/mike9alive/447845750"&gt;&lt;img style="float:left" src="http://farm1.staticflickr.com/204/447845750_87dd3c1a48.jpg" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id="no-coverage"&gt;No coverage&lt;/h3&gt;
&lt;p&gt;Sadly enough - there are code bases with next to no code coverage. This may make it hard to get started.
In these cases it is often best to do some integration tests on the whole first before starting to mess
around. Then - if possible - add unit tests whenever new code is written. Some parts may be next to
impossible to unit test without a non-estimable refactoring. Depending on your budget you’ll have to decide
whether to attempt a refactoring or not. When using static languages it may often be safe to do refactorings
like &lt;em&gt;extract something&lt;/em&gt; and &lt;em&gt;inline something&lt;/em&gt;. It may be enough to get some part of the code into
testable shape.&lt;/p&gt;

&lt;p&gt;Also note that the refactor phase may result in small TDD loops on other parts of the system
in order to do a refactoring safely. This is because you may want to integrate your changes into some part
of the system that currently lack tests. In these cases it may be better to finish the task at hand in a decent
shape before moving on to tackle the needed refactoring in a new red-green-refactor cycle.&lt;/p&gt;

&lt;h3 id="what-about-user-interfaces"&gt;What about user interfaces?&lt;/h3&gt;

&lt;p&gt;Yes! Test them also. That a user interface looks good can never be tested automatically. At least not until
we get sentient AIs that can understand the feelings of humans… But the code inside the user interface
can be tested. Any code that is complex can be extracted into testable units. The actual composition of a
user interface may not be possible to test (depending on the technique used) but the code needed to compose
it sure may. This will also lead to a good separation of concerns in the UI code base. That the whole thing
sits together nicely is best tested with integration/acceptance tests. Most common user interface technologies
have some kind of framework for this and if you lack this there are user interface robots for the common
platforms that knows how to enter characters in fields and click buttons. For the web there are several good
options that also tests dynamic content on a web page. I have good experiences with
&lt;a href="https://github.com/jnicklas/capybara"&gt;capybara&lt;/a&gt; using the webkit driver. In Java land there is
&lt;a href="http://docs.seleniumhq.org/projects/webdriver/"&gt;selenium&lt;/a&gt; that makes it easy to write javascript-aware tests.
For static sites it is even easier.&lt;/p&gt;

&lt;h3 id="what-language-to-write-tests-in"&gt;What language to write tests in?&lt;/h3&gt;

&lt;p&gt;Most of the time it makes sense to write tests in the same language as the units under test. As a developer you
don’t need to switch in another syntax cartridge. But for some languages (Java comes to mind) the amount of
code needed to write anything may make it worthwhile looking at a dynamic languages for tests. Groovy is probably
most handy for testing Java although any dynamic languages that runs on the JVM will do fine.&lt;/p&gt;

&lt;h3 id="continuous-integration"&gt;Continuous integration&lt;/h3&gt;

&lt;p&gt;I have written extensively about &lt;a href="http://highlevelbits.com/2010/11/continuous-integration-essentials.html"&gt;this elsewhere&lt;/a&gt;
so at the moment I will just take it down to: TDD without continuous integration is wasteful.&lt;/p&gt;

&lt;h3 id="so-what-are-the-benefits-of-working-this-way"&gt;So what are the benefits of working this way?&lt;/h3&gt;

&lt;p&gt;There are benefits at several levels. On the personal level TDD gives a sense of accomplishment and a secureness that the
code delivered actually works and adds value to the whole. But this may differ from person to person. The more obvious benefits
are on the organizational level:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;stability - the code base will be stable over time. New features won’t break old ones.&lt;/li&gt;
  &lt;li&gt;predictability - it will be easier to predict the outcome of a project since the code base will be in a known state. Estimates
may actually turn out to be correct!&lt;/li&gt;
  &lt;li&gt;readability - the code produced will be readable which in turn will make the system maintainable.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So the benefits are huge - there are no known disadvantages. If you are not doing TDD today I hope this article sparked
some inspiration. If you feel you need guidance to get going I or one of many other TDD coaches will be happy to help you out.&lt;/p&gt;

&lt;p&gt;While researching images for my TDD presentation I stumbled upon this guy. Kind of not related but awesome nevertheless.&lt;/p&gt;

&lt;p&gt;&lt;a href="http://www.flickr.com/photos/photochiel/2043747282"&gt;&lt;img src="http://farm3.staticflickr.com/2201/2043747282_eaa5239696_b.jpg" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Photo credits to flickr users &lt;a href="http://www.flickr.com/photos/martinlabar"&gt;martinlabar&lt;/a&gt;,
&lt;a href="http://www.flickr.com/photos/mike9alive"&gt;mike9alive&lt;/a&gt; and &lt;a href="http://www.flickr.com/photos/photochiel"&gt;photochiel&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <id>tag:www.highlevelbits.com,2013-04-13:/2013/04/nanoc.html</id>
    <title type="html">moving from drupal to nanoc</title>
    <published>2013-04-12T22:00:00Z</published>
    <updated>2013-04-12T22:00:00Z</updated>
    <link rel="alternate" href="http://www.highlevelbits.com/2013/04/nanoc.html"/>
    <content type="html">&lt;p&gt;Time to move on to the bright (old) new world of static sites. We were not
entirely satisfied with drupal. Not knowing (or wanting to know) the platform
well enough made us unable to produce the awesome site we want high level bits to be.
In comes &lt;a href="http://nanoc.ws/"&gt;nanoc&lt;/a&gt; - what you read here is generated by nanoc.&lt;/p&gt;

&lt;p&gt;The source is now &lt;a href="https://github.com/highlevelbits/blog"&gt;all available at github&lt;/a&gt; so if you want to
contribute a post just clone and pull request away.&lt;/p&gt;

&lt;p&gt;We started by exporting our data from Drupal with &lt;a href="https://github.com/highlevelbits/blog/blob/master/import.rb"&gt;this little Ruby script&lt;/a&gt;
that connects directly with the
drupal database and creates posts and appends old comments to the post. It also updates the
head section with title, timestamp and author. We decided to skip exporting of tags and do a retagging of all
the articles. Well worth the effort.&lt;/p&gt;

&lt;p&gt;The natural choice for hosting is &lt;a href="http://pages.github.com/"&gt;github pages&lt;/a&gt;. It turned out to be rather easy to setup with nanoc.
There was no documentation for how to do it with nanoc so I added a
&lt;a href="https://github.com/froderik/nanoc-site/blob/master/content/docs/guides/deploying-nanoc-sites.md#with-github-pages"&gt;section to the deploy guide&lt;/a&gt;.
(Yet to make it into the main docs.) The instructions in the github docs are straightforward. A little script
automates the deploy procedure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#! /usr/bin/env bash

nanoc prune compile --yes
cd output
git pull origin gh-pages
git add .
git commit -am "high level bits automatic deploy"
git push origin gh-pages
cd ..
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To choose nanoc more or less just happened. I asked a bit on twitter and got nanoc is nice back and started
to play with it. It is nice and so here we are. Hardy had good experiences with awestruct but since he had
less time at the moment I just moved forward with nanoc to try it out.&lt;/p&gt;

&lt;p&gt;All articles have been retagged so hopefully tags make more sense now. We don’t have a tags page anymore. Instead
posts with similar tags are shown at the bottom of the page.&lt;/p&gt;

&lt;p&gt;The &lt;a href="/archive.html"&gt;archive page&lt;/a&gt; was fun to build. I decided to try to do foldable sections without using javascript using the checkbox
trick. Check the code to find out how it works.&lt;/p&gt;

&lt;p&gt;All in all a nice experience. I may well do other sites with nanoc in the future.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <id>tag:www.highlevelbits.com,2012-05-28:/2012/05/far-east-culture.html</id>
    <title type="html">Far east culture</title>
    <published>2012-05-27T22:12:15Z</published>
    <updated>2012-05-27T22:12:15Z</updated>
    <link rel="alternate" href="http://www.highlevelbits.com/2012/05/far-east-culture.html"/>
    <content type="html">&lt;p&gt;I had in mind a series of posts about our trip to the far east but I realize that it will not happen with everything else that is happening now. So I will settle on writing a bit about the culture of Japan and Korea. Beer in mind that we only spent about 3 weeks in total so there is plenty of room for misunderstandings. &lt;/p&gt;

&lt;p&gt;&lt;img src="http://farm8.staticflickr.com/7089/6965682494_87406a6cf0.jpg" alt="harajuku" /&gt;&lt;/p&gt;

&lt;p&gt;The first thing that went missing when leaving Japan is polite and smiling people. In almost every shop you are welcomed by a smiling person that says something to you. Back in Sweden it is rather the exception. Also when looking lost in a street corner with a map there is always someone trying to help. This was even more apparent in Korea than in Japan. Seoul was a bit friendlier in this resepect compared to Japan. All in all I don’t think we met a single person that was not friendly during the trip.&lt;/p&gt;

&lt;p&gt;The low tax on income makes it worthwhile to have small businesses which makes cities much more lively. There are so many small enterprises in both Japan and Korea that makes the countries more alive. It is also something that makes it easier to find something to eat. And yes - the food is awesome. Japanese food is of course about the fish and the rice which we had plenty. But it is also about yakitori, ramen and udon. One of the best meals was a lunch in Kyoto where we got noodles on a fry bench (griddles? - a bit lost about the english word for this….). Korean cuisine may not be that famous in the west but stands up really good. It is not only about the kimchi and it is certainly not just spicy chilliish food as the guide book said. Korean BBQ is often prepared at the table by the guests or by a chef. With meat of good quality and all the nice side dishes it makes for a really intimate way to share a meal. We also took a liking to korean breakfast. It is much the same as a “normal” meal but in smaller quantities. The kimchi and the ever present soup is there and maybe one smaller dish with meat or fish. Also - the ever present cup of tasty green tea. The only thing to grow tired of is all that rice.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://farm8.staticflickr.com/7055/7053758185_b0364ae8a5.jpg" alt="udon" /&gt;&lt;/p&gt;

&lt;p&gt;From food it is easy to move on to cleanliness. Most restaurants give you warm or cold small wet towels to clean yourself before starting to eat. Such a nice thing to start every meal feeling refreshed especially after a couple of hours of sightseeing. Another great thing about these countries are restrooms everywhere. Every building in Japan seem to have a tidy public restroom. &lt;/p&gt;

&lt;p&gt;We did a bit of sampling of the Japanese onsen (bathing) culture. In Beppu we stayed at a hotel with a couple of private baths that you could book for free by the hour. True balm for the soul to sit in these warm baths and just exist for a while. We could have done much more of this side of Japan but so much to see and just 3 weeks to spend.&lt;/p&gt;

&lt;p&gt;A nice trip and there may be more of the far east soon. Käthes youngest daughter is about to study in Shanghai for a year so maybe we will “have to” visit her around christmas.&lt;/p&gt;
&lt;div class="old-comments"&gt;&lt;h2&gt;Old comments&lt;/h2&gt;&lt;div class="one-old-comment"&gt;&lt;span class="comment-date"&gt;2012-06-07&lt;/span&gt;&lt;span class="commenter-name"&gt;hardy&lt;/span&gt;&lt;div class="comment-body"&gt;Ahh, sounds awesome. Food, baths and sauna. My passions. I think I need to plan a trip to Japan as well :-)&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content>
  </entry>
  <entry>
    <id>tag:www.highlevelbits.com,2012-05-18:/2012/05/perfect-day.html</id>
    <title type="html">A perfect day</title>
    <published>2012-05-17T22:55:47Z</published>
    <updated>2012-05-17T22:55:47Z</updated>
    <link rel="alternate" href="http://www.highlevelbits.com/2012/05/perfect-day.html"/>
    <content type="html">&lt;ul&gt;
  &lt;li&gt;Train ride to &lt;a href="http://en.wikipedia.org/wiki/Copenhagen"&gt;Copenhagen&lt;/a&gt; playing &lt;a href="http://eu.battle.net/d3/en/?-"&gt;Diablo III&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;30 minutes tunnel at &lt;a href="http://www.airexperience.dk/"&gt;Copenhagen Air Experience&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Dinner at &lt;a href="http://nose2tail.dk/"&gt;Nose2Tail&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Train ride to Göteborg listening to &lt;a href="http://www.udo-lindenberg.de/mtv_unplugged.80021.htm"&gt;Udo Lidenberg &amp;amp; Das Panik-Orchester MTV Unplugged&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;:-)&lt;/p&gt;
&lt;div class="old-comments"&gt;&lt;h2&gt;Old comments&lt;/h2&gt;&lt;div class="one-old-comment"&gt;&lt;span class="comment-date"&gt;2012-08-31&lt;/span&gt;&lt;span class="commenter-name"&gt;diablo guide demon hunter&lt;/span&gt;&lt;div class="comment-body"&gt;&amp;#1053;&amp;#1110; there, yup th&amp;#1110;s post i&amp;#1109; actually n&amp;#1110;c&amp;#1077; an&amp;#1281; &amp;#1231;
have learned lot of th&amp;#1110;ngs from it c&amp;#959;n&amp;#1089;erning blogging.
than&amp;kappa;s.&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content>
  </entry>
</feed>
